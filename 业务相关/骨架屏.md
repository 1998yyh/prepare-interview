# sdk-skeleton 骨架屏

## 特点 
1. 轻量 骨架屏生成工具包体积只有10kb

2. 无侵入 骨架屏的生成、调试仅在dev环境运行，对生产环境及项目代码无侵入

3. 高灵活度 产物为骨架屏html代码，方便进行二次开发

4. 易调试 骨架屏可在原页面上直接调试，便于美化和验证还原度。

## 配置

```ts
interface Options {
  name: string
  rootNode: string // 根元素 默认为body
  nodeDeep: number // 节点深度 默认 6
  skeletonColor: string; // 骨架颜色 默认 #EEEEEE
  isDebug: boolean // 是否调试 
}
```

## 思想 

从根节点开始,深度遍历元素，如果元素携带有ignore属性 则忽略该元素，否则push到一个element数组中。然后针对每个元素 获取到他的boundingClientRect 来给其设置样式。

##　代码

``` ts
  /* 处理页面dom tree */
  private generateSkeleton (): Element {
    // 获取所有要添加骨架屏的元素节点
    const domList = this.dfsDom(document.querySelector(this.options.rootNode)!);
    // 获取所有元素节点的样式节点
    const skeletonRectList = domList.map((item) => {
      return this.getSkeletonElementRect(item);
    });
    // 如果元素不在页面内 即 轮播图外部等 
    const notContainedRectList = this.findNotContainedRect(uniqueSkeletonRectList);
    // 创建 并且添加到页面中
    const skeletonContent = document.createElement('div');
    skeletonContent.setAttribute('id', SKELETON_CONTENT_ID);
    notContainedRectList.forEach((rect: SkeletonRect) => {
      const element = this.createSkeletonElement(rect);
      element && skeletonContent.appendChild(element);
    });
    return skeletonContent;
  }


  /* 深度优先遍历dom */
  private dfsDom (node: Element, res: Element[] = [], level = 1) {
    if (node && level <= this.options.nodeDeep) {
      // 忽略的情况
      if (!node.hasAttribute('skeleton-ignore') && this.getNeedHandleDom(node)) {
        res.push(node);
      }
      if (!node.hasAttribute('skeleton-ignore-children')) {
        const children = node.children;
        for (let i = 0; i < children.length; i++) {
          this.dfsDom(children[i], res, level + 1);
        }
      }
    }
    return res;
  }
```


## 其他的解决方案 是用无头浏览器 例如 puppeteer 获取到DOM后 进行canvas或者svg等绘制 然后插入到页面中 