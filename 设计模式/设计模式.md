# 设计模式

## 工厂模式

## 单例模式

## 原型模式

## 装饰器模式

## 代理模式
最常见的四种代理类型：事件代理、虚拟代理、缓存代理和保护代理

1.事件代理 事件本身具有“冒泡”的特性，当我们点击元素时，点击事件会“冒泡”到父元素上，从而被监听到。如此一来，点击事件的监听函数只需要在父元素上被绑定一次即可，而不需要在子元素上被绑定 N 次——这种做法就是事件代理，它可以很大程度上提高我们代码的性能。

2.虚拟代理 图片懒加载与预加载 [代码在此](./代理模式/imgPreload.js)
3.缓存代理 它应用于一些计算量较大的场景里。在这种场景下，我们需要“用空间换时间”——当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算，而是希望能从内存里去取出现成的计算结果[代码在此](./代理模式/cacheProxy.js)
4.保护代理 是在访问层面做文章，在 getter 和 setter 函数里去进行校验和拦截，确保一部分变量是安全的。


## 策略模式
定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
[代码在此](./策略模式/index.js)

## 状态模式
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
[代码在此](./状态模式/index.js)

策略模式中的行为函数是”潇洒“的行为函数，它们不依赖调用主体、互相平行、各自为政，井水不犯河水。
而状态模式中的行为函数，首先是和状态主体之间存在着关联，由状态主体把它们串在一起；另一方面，正因为关联着同样的一个（或一类）主体，所以不同状态对应的行为函数可能并不会特别割裂。

## 观察者模式
详情见[观察者](./观察者（订阅发布）/观察者.md)

## 迭代器模式



发现的一些问题：
1.来自[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)

``` javascript
// 必须构造 String 对象以避免字符串字面量 auto-boxing
var someString = new String("hi");
someString[Symbol.iterator] = function() {
  return { // 只返回一次元素，字符串 "bye"，的迭代器对象
    next: function() {
      if (this._first) {
        this._first = false;
        return { value: "bye", done: false };
      } else {
        return { done: true };
      }
    },
    _first: true
  };
};
```

auto-boxing

2.来自[stackoverflow](https://stackoverflow.com/questions/17256182/what-is-the-difference-between-string-primitives-and-string-objects-in-javascrip/17256340#17256340)
```javascript

var s = '0123456789';
for (var i = 0; i < s.length; i++) {
  s.charAt(i);
}
```
```javascript

var s = new String('0123456789');
for (var i = 0; i < s.length; i++) {
    s.charAt(i);
}
``` 
以上两个代码段哪个执行的更快？



自己定义的 生成器(Generator)

``` javascript
function iteratorGenerator(list){
  const index = 0;
  const _list = list;
  return {
    next:function(){
      const done = index>=_list.leng
      const value = !done:_list[index++]:undefined
      return {
        done,
        value
      }
    }
  }
}

var iterator = iteratorGenerator(['1号选手', '2号选手', '3号选手'])
iterator.next()
iterator.next()
iterator.next()

```


