# 从浏览器地址栏输入url到请求返回发生了什么

## 进行URL解析，根据dns系统进行ip查找

### 先说为什么url要解析（也就是编码)
1.网络标准规定了URL只能是字母和数字，还有其他符号。
2.不转译会有歧义，比如key=y=value；
#### url编码规则是什么
1.utf-8 
查了一下:
pathInfo部分默认使用的是utf-8
queryString部分IE9使用的是GB2312编码，其他浏览器使用的是utf-8
资源来自于[https://blog.csdn.net/u014785687/article/details/74078512](https://blog.csdn.net/u014785687/article/details/74078512)

#### 怎么保证都是utf-8的编码?

1.html文件指定编码<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
2.使用 encodeURIComponent 

#### encodeURIComponent比encodeURI有什么区别?
1.encodeURIComponent编码范围更广，适合给参数编码,它对它发现的任何非标准字符进行编码
2.encodeURI适合给URL本身（locaion.origin）编码,不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号
举个例子：
encodeURI('mai@up366.com')  =>"mai@up366.com"
encodeURIComponent('mai@up366.com') =>"mai%40up366.com"



### 然后说说dns解析流程，并且html如何做dns优化
1.系统查hosts文件是否有记录，有的话把对应映射的ip返回
2.hosts文件没有的话就去查本地dns解析器是否有缓存
3.本地dns也没有的话，我们回去找dns服务器上是否缓存，如果有返回。
4.还没有的话去根DNS服务器找固定IP地址，然后根据域名是哪个服务器管理，从后往前逐层看能否被解析，直到查到对于ip
地址

dns优化
```javascript
// DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />

```



## 查到IP之后，就是http协议的三次握手四次挥手

### 3次握手发生了什么
1.主机A发送位码为SYN=1的TCP包给服务器，并且随机产生一个作为确认号（这是TCP包的一部分），主机B收到SYN码后知道A要求建立连接
2.主机B收到请求后，向A发送确认号（主机A的seq+1），SYN=1，SEQ=随机数的TCP包
3.主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认浩（主机B的seq+1），ack=1，主机B收到后确认seq值与ack=1，连接建立成功

### 为啥两次不行

因为第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。

### 网卡把数据包传输出去到服务器发生了什么  参考OSI模型

#### OSI模型
OSI：开放式系统互联通信参考模型
七层结构
应用层：为应用程序提供服务
表示层：数据格式化转化，数据加密
会话层：建立，管理和维护会话
传输层：建立，管理和维护端对端的连接
网络层：IP选址及路由选择
数据链路层：提供介质访问和链路管理
物理层：物理层

#### 网卡把数据包传输出去到服务器发生了什么
1.先从局域网把护具发送到交换机，交换机的好处是可以隔离冲突域（因为以太网使用的CSMA/CD协议，这个协议规定网线上同一时刻只能由一台机器发送数据），这样就可以不仅仅同一时刻只有一台机器发送网络包了
2.然后交换机再将数据发送给路由器，路由器具有转发和分组数据包的功能，这算是经过了物理层，数据链路层，开始到网络层进行数据转发了
3.然后路由器转发IP数据包，一般公司的IP地址会经过NAT转换（网络地址转换），通过路由器的分组传输，所有数据到达服务器
4.服务器上层的传输层根据tcp包里的端口号，让服务器特定的服务来处理到来的数据包。tcp是面向字节流的（tcp有四大特性，可靠传输，流量控制，拥塞控制，连接管理）
5.最后数据由传输层转交给应用层，后端处理给前端数据。

## 建立完链接，就该请求html文件了，如果html文件在缓存里面浏览器直接返回，如果没有，就去后台拿

### 缓存解释一下
1.浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅把资源下载下来，还会把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存
2.下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高。比如cache-control:no-cache就直接进入到协商缓存的步骤，如果cache-control:max-age=xxx，就会比较当前时间和上一次返回200的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件，过期的话会进入下一个阶段，协商缓存。
3.协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag（被请求变量的实体值，Etag是服务端的一个资源的标识），如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;
4.协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;


### 什么是from disk cache和from memory cache吗，什么时候会触发？
from disk cache 从硬盘获取
from memory cache 从内存获取

#### 三级缓存原理
1. 先去内存看，如果有，直接加载
2. 如果内存没有，择取硬盘获取，如果有直接加载
3. 如果硬盘也没有，那么就进行网络请求
4. 加载到的资源缓存到硬盘和内存

以图片为例
访问-> 200 -> 退出浏览器
再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)

常见的用户行为
1. 打开新窗口：如果命中了强缓存，则请求 disk cache；否则请求服务器；
2. 刷新：如果存在缓存，优先命中 memory cache，其次是 disk cache；否则请求服务器；
3. 强制刷新：请求服务器获取最新资源；
4. 地址栏输入：同刷新


### 启发式缓存

当既没有设置 max-age 相对时间，也没有设置 exprires 绝对时间的时候，浏览器依然会请求缓存的内容，而不是请求服务器走。

启发式缓存策略，它的计算方式为根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。


## 返回html之后，会解析html
1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；
5.渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。
6.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
7.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；

以上这部分都是过时的说法（16年之前确实是这种的）：
以下这部分

### 新版渲染流程
1.构建DOM树。
2.样式计算，当渲染引擎接收到css文本时，执行一个转换操作，将css文本转化为浏览器可以理解的结构-styleSheets，此过程中会将属性值，标准话比如em->px，blue->rgb(0,0,255)，blod->700等等。然后计算出DOM树中每个节点的具体样式，涉及到css的继承规则和层叠规则
3.布局阶段，计算出DOM树中可见元素的集合位置。chrome在布局阶段会完成两个任务，创建布局树和布局计算。 创建布局树：遍历DOM树中的所有可见节点，并把这些节点加到布局树中。在执行布局操作的时候，会把布局运算的结果写回到布局树中，所以布局树既是输入内容，也是输出内容，这就是布局阶段一个不合理的地方，没有把输入和输出分开。Chrome正在优化，下一代布局系统LayoutNg试图更清晰分离输入和输出。
4.分层：渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。浏览器的页面实际上被分成了很多图层，这些图层叠加后成了最终的页面。并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。拥有层叠上下文属性的元素会被提升为单独的一层。需要剪裁（clip）的地方也会被创建为图层（例如overflow:hidden)。
5.图层绘制
6.栅格化（raster）操作,合成线程会将图层划分为图块（tile）合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。
7.合成和显示,一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”,浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。


## 页面渲染优化
随便抄了几个
HTML文档结构层次尽量少，最好不深于六层；
脚本尽量后放，放在前即可；
少量首屏样式内联放在标签内；
样式结构层次尽量简单；
在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；
减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；
动画尽量使用在绝对定位或固定定位的元素上；
隐藏在屏幕外，或在页面滚动时，尽量停止动画；
尽量缓存DOM查找，查找器尽量简洁；
涉及多域名的网站，可以开启域名预解析


资料来源：
文章主要来源[https://juejin.cn/post/6928677404332425223](https://juejin.cn/post/6928677404332425223)
极客时间浏览器课程[https://time.geekbang.org/column/intro/216](https://time.geekbang.org/column/intro/216)
浏览器缓存相关[https://zhuanlan.zhihu.com/p/187007073](https://zhuanlan.zhihu.com/p/187007073)
层叠上下文问题[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)
