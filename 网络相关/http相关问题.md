# 彻底搞懂HTTP知识的面试题
原文地址:[https://juejin.cn/post/6956028222806949901#heading-54](https://juejin.cn/post/6956028222806949901#heading-54)

## 如何理解URI
URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。它不是我们一般说的URL，指的是URL+URN，由于URL过于普及，默认将URI视为URL了。

### URI的结构

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/340fe9cb7fef4e03941cb17c79f79c49~tplv-k3u1fbpfcp-zoom-1.image)

* scheme  表示协议名，比如http, https, file等等。后面必须和://连在一起。
* user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。
* host:port 表示主机名和端口。
* path 表示请求路径，标记资源所在位置。
* query 表示查询参数，为key=val这种形式，多个键值对之间用&隔开。
* fragment 表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。

## HTTP 超文本传输协议

### HTTP 的特点？HTTP 有哪些缺点？

#### HTTP 的特点概括
* 灵活可扩展
	* 一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制
	* 另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
* 可靠传输 HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
* 请求-应答 也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。
* 无状态 这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息

#### HTTP 缺点
* 无状态 所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
	* 在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
	* 但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。
* 明文传输，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利
* 队头阻塞问题，当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。

## HTTP 报文结构是怎样的？

header + body 的结构，具体而言:
```javascript
起始行 + 头部 + 空行 + 实体
```

### 起始行
请求报文： GET /home HTTP/1.1  对应的是 **方法** + **路径** +  **http版本**
响应报文： HTTP/1.1 200 OK 对应的是 **http版本** + **状态码** + **原因**

**注意**：在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循 ABNF 语法规范

### 头部

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43f6e8525aba4627a6342ea40ee1caa8~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d9e8c160d254922ae4f05baf1148a0a~tplv-k3u1fbpfcp-zoom-1.image)

头部的格式：
*  字段名不区分大小写
*  字段名不允许出现空格，不可以出现下划线 `_`
*  字段名后面必须紧接着 `:`

### 空行
很重要，用来区分开头部和实体。

问: 如果说在头部中间故意加一个空行会怎么样？
那么空行后的内容全部被视为实体。

### 实体
就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体。


## 如何理解 HTTP 的请求方法？
http/1.1 规定了以下请求方法(注意，都是大写):
* GET 通常用来获取资源
* HEAD 获取资源的元信息
* POST 提交数据，即上传数据
* PUT 修改数据
* DELETE 删除资源(几乎用不到)
* CONNECT 建立连接隧道，用于代理服务器
* OPTIONS 列出可对资源实行的请求方法，预检请求，用来跨域请求
* TRACE 追踪请求-响应的传输路径

## GET 与 POST

### 说一下 GET 和 POST 的区别？
首先最直观的是语义上的区别（get用于获取数据,post用于提交数据）
而后又有这样一些具体的差别:
* 从缓存的角度 GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
* 从编码的角度 GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
* 从参数的角度 GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
* 从幂等性的角度 GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
* 从TCP的角度 GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分(预检请求)，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

### 状态码

#### 1x 
提示中间状态，实际用的比较少

#### 2x 
200是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
204也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
206是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

#### 3x 
301 永久重定向
302 临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
304 缓存重定向

#### 4x 
400 表示客户端请求的报文有错误，但只是个笼统的错误
403 服务端禁止访问
404 资源在服务器上不存在或未找到，所以无法提供给客户端
#### 5x 
500 是个笼统通用的错误码，服务器发生了什么错误，我们并不知道
501 表示客户端请求的功能还不支持
502 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
503 表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。


### http 常见字段有哪些？
#### Host
客户端发送请求时，用来指定服务器的域名

#### Content-Length
服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。

#### Connection
Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用
``` javascript
Connection: keep-alive
```
#### Content-Encoding
Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

#### Content-type
Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式

#### Accept
对于 Accept 系列字段的介绍分为四个部分:数据格式、压缩方式、支持语言和字符集


## 对于定长和不定长的数据，HTTP 是怎么传输的？
### 定长包体
服务端发送的时候会带Content-Length字段 来指明包的长度；如果内容比这个长度短，会被截取
```javascript
const http = require('http');
const server = http.createSever();

server.on('request',(req,res)=>{
	if(req === '/'){
		res.setHeader('Content-Type','text/html')
		res.setHeader('Content-Length',4);
		res.write('helloworld');  // 收到的只有hell
	}
})

server.listen('8000',()=>{
	console.lgo('111')
})

```

如果我们设置的长度偏大，则会传输出错

### 不定长包体
Transfer-Encoding: chunked
表示分块传输数据，设置这个字段后会自动产生两个效果:

* Content-Length 字段会被忽略
* 基于长连接持续推送动态内容

``` javascript

const http = require('http');
const server = http.createServer();

server.on('request',(req,res)=>{
	res.setHeader('Content-Type', 'text/html; charset=utf8');
	res.setHeader('Content-Length', 10);
	res.setHeader('Transfer-Encoding', 'chunked');
	res.write("<p>来啦</p>");
	setTimeout(() => {
		res.write("第一次传输<br/>");
	}, 1000);
	setTimeout(() => {
		res.write("第二次传输");
		res.end()
	}, 2000);
})

```


## HTTP 如何处理大文件的传输？

## HTTP 中如何处理表单数据的提交？
在 http 中，有两种主要的表单提交的方式，体现在两种不同的Content-Type取值:

### application/x-www-form-urlencoded
对于application/x-www-form-urlencoded格式的表单内容，有以下特点:
* 其中的数据会被编码成以&分隔的键值对
* 字符以URL编码方式编码。如：
### multipart/form-data
对于multipart/form-data而言:
* 请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。
* 数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上--表示结束。

multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。
在实际的场景中，对于图片等文件的上传，基本采用multipart/form-data而不用application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。


## 如何理解 HTTP 代理？

HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。
当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。

### 功能
* 负载均衡 客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。
* 保障安全 利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群，并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。
* 缓存代理，将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用从原服务获取。

### 相关头部字段

#### VIA 
代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？
通过Via字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:
``` javascript
客户端 -> 代理1 -> 代理2 -> 源服务器
```
在源服务器收到请求后，会在请求头拿到这个字段：
``` javascript
Via: proxy_server1, proxy_server2
```

而源服务器响应时，最终在客户端会拿到这样的响应头:
``` javascript
Via: proxy_server2, proxy_server1
```
Via中代理的顺序即为在 HTTP 传输中报文传达的顺序

### X-Forwarded-For
字面意思就是为谁转发，它记录的是请求方的IP地址(注意，和Via区分开，X-Forwarded-For记录的是请求方这一个IP)。

### X-Real-IP
是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。
相应的，还有X-Forwarded-Host和X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。

### X-Forwarded-For产生的问题
* 必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。
* 在 HTTPS 通信加密的过程中，原始报文是不允许修改的。

由此产生了代理协议，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:

``` javascript
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
```




## HTTP1.1

### HTTP1.1 的优点有哪些，怎么体现的？
HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」
* HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛
* HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充
* 同时 HTTP 由于是工作在应用层（OSI 第七层），则它下层可以随意变化
* HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC
* 互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性

### 怎么理解SSL/TLS
TLS 和 SSL是其实是一个同种意思
* SSL 是"Secure Sockets Layer" 的缩写，中文叫做「安全套接层」。它是在上世纪 90 年代中期，由网景公司设计的。在 OSI 七层模型中处于会话层(第 5 层)
* TLS 是 "Transport Layer Security"，中文叫做 「传输层安全协议」。因为到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS

### HTTP1.1 的的缺点呢？

HTTP 协议里有优缺点一体的双刃剑，分别是 无状态、明文传输，同时还有一大缺点不安全
无状态：服务器不需要记录http状态，减少负担；无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。
如何解决： 携带Cookie

明文传输：可阅读，调试方便；相反的容易被攻击。

不安全：明文传输；不验证通信者身份；不验证报文的完整性；


### 那你在说下 HTTP/1.1 的性能如何？

* 长连接
	* 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。
	* 为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接(Connection: keep-alive)。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
	* 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态
	* 并发连接 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个
	* 域名分片 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名，比如 content1.sanyuan.com 、content2.sanyuan.com。这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题
* 管道网络传输
  * 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
  * 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为**队头堵塞**
* 队头阻塞
  * 「请求 - 应答」的模式加剧了 HTTP 的性能问题
  * 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。

## HTTP1.1、HTTP2、HTTP3 演变

### 说说 HTTP1.1 相比 HTTP1.0 提高了什么性能？

*  HTTP1.1 相比 HTTP1.0 性能上的改进：
  * 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
  * 支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
* 但 HTTP1.1 还是有性能瓶颈：
  * **请求/响应头部（Header）未经压缩就发送**，首部信息越多延迟越大。只能压缩 Body 的部分
  * **发送冗长的首部**。每次互相发送相同的首部造成的浪费较多
  * 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是**队头阻塞**；
  * **没有请求优先级控制**
  * **请求只能从客户端开始**，服务器只能被动响应

### 

### 那上面的 HTTP1.1 的性能瓶颈，HTTP2 做了什么优化？

1. #### 头部压缩

   HTTP2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。

   在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2. #### 二进制格式

   HTTP2 不再像 HTTP1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧(frame)：头信息帧和数据帧。

   这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率

3. #### 数据流

   HTTP2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

   每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。

4. #### 多路复用

   HTTP2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
   移除了 HTTP1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。

5. #### 服务器推送

   HTTP2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。
    举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送(Server Push，也叫 Cache Push)



## HTTP2 有哪些缺陷？HTTP3 做了哪些优化？

HTTP2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

这都是基于 TCP 传输层的问题，所以 **HTTP3 把 HTTP 下层的 TCP 协议改成了 UDP**！

1. QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。
2. TL3 升级成了最新的1.3版本，头部压缩算法也升级成了 QPack
3. HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互 **合并成了 3 次，减少了交互次数**



## HTTP 与 HTTPS

### HTTP 与 HTTPS 有哪些区别？

* HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行SSL/TLS 的握手过程，才可进入加密报文传输。
* HTTP 的端口号是 80，HTTPS 的端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

### HTTPS 解决了 HTTP 的哪些问题？

* **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
* **篡改风险**，比如强制入垃圾广告，视觉污染，用户眼容易瞎。
* **冒充风险**，比如冒充淘宝网站，用户钱容易没。

通过使用SSL / TLS 加密解决以上问题

* 混合加密的方式实现信息的机密性，解决了窃听的风险。
* 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
* 将服务器公钥放入到数字证书中，解决了冒充的风险

#### 混合加密

混合加密HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：

* 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
* 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：

* 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
* 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。



#### 摘要算法

摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险

客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同 加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。

#### 数字证书

将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。



### HTTPS 是如何建立连接的？其间交互了什么？

SSL/TLS 协议基本流程：

1. TCP 三次同步握手
2. 客户端向服务器索要并验证服务器的公钥
3. 双方协商生产「会话秘钥」
4. SSL 安全加密隧道协商完成
5. 双方采用「会话秘钥」进行加密通信。

SSL/TLS 协议建立的详细流程：

#### 1. ClientHello

首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。
 在这一步，客户端主要向服务器发送以下信息：
 （1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
 （2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。
 （3）客户端支持的密码套件列表，如 RSA 加密算法。

#### 2. SeverHello

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：
 （1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。
 （2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。
 （3）确认的密码套件列表，如 RSA 加密算法。
 （4）服务器的数字证书

#### 3. 客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
 （2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
 （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。
 上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」

#### 4. 服务器的最后回应

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：
 （1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。
 至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。



