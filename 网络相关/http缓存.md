# http 缓存
[原文地址](https://juejin.cn/post/6963619263558991908);

## 什么是浏览器缓存
## 为什么使用缓存

## 浏览器端的缓存规则

对于浏览器端的缓存来讲，这些规则是在 **HTTP协议头 **和 **HTML页面的Meta标签 **中定义的。他们分别从 新鲜度 和 校验值 两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。

## 浏览器缓存的控制

### 使用HTML Meta 标签

``` html
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache">
<META HTTP-EQUIV="Expires" CONTENT="0">

```

### 使用缓存有关的HTTP消息报头

#### 强缓存 Cache-Control 与 Expires
Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires

* Expires:即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样
``` javascript
Mon, 15 Aug 2021 03:56:47 GMT
```
表示资源在2021年8月15号03点56分过期，过期了就得向服务端发请求。 这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。

* Cache-Control:采用过期时长来控制缓存，对应的字段是max-age。
  ```javascript
  Cache-Control:max-age=3600
  ```

+ public 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。
+ private 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
+ no-cache 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
+ no-store 非常粗暴，不进行任何形式的缓存。
+ s-maxage 这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。


#### 协商缓存 Last-Modified 与 ETag
你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：
+ Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度
+ 如果某些文件会被定期生成(或编辑了资源文件)，但是文件内容并没有更改，但Last-Modified却改变了，导致文件没法使用缓存
+ 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

##### Last-Modified
即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在 响应头 中加上这个字段。
浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since 字段，这个字段的值也就是服务器传来的最后修改时间。
服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:

* 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
* 否则返回304，告诉浏览器直接用缓存

##### ETag
