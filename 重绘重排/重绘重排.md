# 重绘重排

回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。

重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。

所以 重绘不一定回流 回流一定会重绘。


## 从浏览器渲染

现代浏览器引擎分为渲染引擎和js引擎；

其中我们最需要关注的，就是HTML 解释器、CSS 解释器、图层布局计算模块、视图绘制模块与JavaScript 引擎这几大模块：

+ HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。
  - 加载资源，发出资源请求。在此过程中DOM树
  - 当HTML解析器遇到script标签时，会暂停渲染引擎，去开启js引擎，所以会阻塞DOM解析，这就是把script放到底部的原因。（这种情况指的是script 没有async 和 defer 属性，如果有这两个属性，会是异步加载，async会加载完立即执行，defer会在 DOMContentLoaded 事件触发后执行。

+ CSS 解释器：解析 CSS 文档, 生成样式规则。
  - 此过程是和HTML解析并行的，会生成CSSOM树。
  - 加载所有css信息与DOM树结合，::before和::after就是在此过程中挂在dom树上的，

+ 图层布局计算模块：布局计算每个对象的精确位置和大小。
  - 页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。

+ 视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。
  - 在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。

+ JavaScript 引擎：编译执行 Javascript 代码。
  - 最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。


## 哪些操作会引起回流

1.改变DOM的几何属性
2.改变DOM的树结构
3.获取一些特定属性的值 offsetTop、offsetLeft、 offsetWidth等等，这些属性需要浏览器即时去计算，。因此浏览器为了获取这些值，也会进行回流。


## 哪些操作会引起重绘

只要是不触发回流，但又触发了样式改变的 DOM 操作，都会引起重绘，比如背景色、文字色、可见性(可见性这里特指形如visibility: hidden这样不改变元素位置和存在性的、单纯针对可见性的操作，注意与display:none进行区分)等。

## 解决方案

### 优化DOM操作

1.减少DOM操作

把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》

+ 插入dom一次性插入不要分开多次。
+ 使用速度更快的API document.querySelector() 替换
+ 使用事件委托
+ 直接dom修改样式替换为修改类

2.渲染的时机。

假如我想要在异步任务里进行DOM更新，我该把它包装成 micro(微任务) 还是 macro(宏任务) 呢？

微任务可以蹭到最近的一个宏任务里


### 动画优化

1.使用浏览器优化的属性
以下这些属性消耗成本低：
position（位置）: transform: translate(npx, npx)
scale（比例缩放）：transform: scale(n)
rotation（旋转） ：transform: rotate(ndeg)
opacity（透明度）：opacity： 0...1

不同样式在消耗性能方面是不同的，改变一些属性的开销比改变其他属性要多，因此更可能使动画卡顿。

例如，与改变元素的文本颜色相比，改变元素的 box-shadow 将需要开销大很多的绘图操作。 改变元素的 width 可能比改变其 transform 要多一些开销。
如 box-shadow 属性，从渲染角度来讲十分耗性能，原因就是与其他样式相比，它们的绘制代码执行时间过长。

这就是说，如果一个耗性能严重的样式经常需要重绘，那么你就会遇到性能问题。其次你要知道，没有不变的事情，在今天性能很差的样式，可能明天就被优化，并且浏览器之间也存在差异。


2.开启GPU加速

上述四种属性的动画消耗较低的原因是会开启了 GPU 硬件加速。动画元素生成了自己的图形层（GraphicsLayer）
通常我们开启GPU加速 使用的是 will-change: transform

使用 will-change 并不一定会有性能的提升，因为即使浏览器预料到会有这些更改，依然会为这些属性运行布局和绘制流程，所以提前告诉浏览器，也并不会有太多性能上的提升。这样做的好处是，创建新的图层代价很高，而等到需要时匆忙地创建，不如一开始直接创建好。

对于旧版的浏览器使用transformZ(0)


3.控制图层关系


动画层级的控制的意思是尽量让需要进行 CSS 动画的元素的 z-index 保持在页面最上方，避免浏览器创建不必要的图形层（GraphicsLayer），能够很好的提升渲染性能。

简单来说，浏览器为了提升动画的性能，为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层，合成层拥有单独的 GraphicsLayer。

需要进行动画的元素包含在这个合成层之下，这样动画的每一帧只需要去重新绘制这个 Graphics Layer 即可，从而达到提升动画性能的目的。

那么一个元素什么时候会触发创建一个 Graphics Layer 层？从目前来说，满足以下任意情况便会创建层：

+ 硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）
+ 硬件加速的插件，比如 flash 等等
+ 使用加速视频解码的 <video> 元素
+ 3D 或者 硬件加速的 2D Canvas 元素
+ 3D 或透视变换 (perspective、transform) 的 CSS 属性
+ 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
+ 拥有加速 CSS 过滤器的元素
+ 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
+ 元素有一个 z-index 较低且包含一个复合层的兄弟元素


此处说的是最后一个点
1.我们希望我们的动画得到 GPU 硬件加速，所以我们会利用类似 transform: translateZ() 这样的方式生成一个 Graphics Layer 层。
2.Graphics Layer 虽好，但不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的 Graphics Layer ，并计算他们下一帧的重绘区域，所以过量的 Graphics Layer 计算也会给渲染造成性能影响。

例如:[DEMO](./GPU问题.html) 
开启layout border 可看到并没有给下面的 list 也添加任何能触发生成 Graphics Layer 的属性，但是它也同样也有黄色的边框，生成了一个独立的复合层。
修改css 使得 .swiper 的层级高于 .list 解决

需要补充的是

GPU 硬件加速也会有坑，当我们希望使用利用类似 transform: translate3d() 这样的方式开启 GPU 硬件加速，一定要注意元素层级的关系，尽量保持让需要进行 CSS 动画的元素的 z-index 保持在页面最上方。

Graphics Layer 不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的 Graphics Layer ，并计算他们下一帧的重绘区域，所以过量的 Graphics Layer 计算也会给渲染造成性能影响。

可以使用 Chrome ，用上面介绍的两个工具对自己的页面生成的 Graphics Layer 和元素层级进行观察然后进行相应修改。

上面观察页面层级的 chrome 工具非常吃内存？好像还是一个处于实验室的功能，分析稍微大一点的页面容易直接卡死，所以要多学会使用第一种观察黄色边框的方式查看页面生成的 Graphics Layer 这种方式。


### contain 

contain 属性允许我们指定特定的 DOM 元素和它的子元素，让它们能够独立于整个 DOM 树结构之外。目的是能够让浏览器有能力只对部分元素进行重绘、重排，而不必每次都针对整个页面。

具体用法 -- [CSS新特性contain，控制页面的重绘与重排](https://github.com/chokcoco/iCSS/issues/23)

但是这个属性的坑比较多 不建议使用。




来源：
[前端性能优化原理与实践](https://juejin.cn/book/6844733750048210957/section/6844733750119497741)
[提高 CSS 动画性能的正确姿势 | 盒子端 CSS 动画性能提升研究](https://github.com/chokcoco/iCSS/issues/11)
[国外老哥博客遇到的坑 GPU加速相关](https://dzhavat.github.io/2021/02/18/debugging-layout-repaint-issues-triggered-by-css-transition.html?utm_source=CSS-Weekly&utm_campaign=Issue-448&utm_medium=email)