# 牛客网刷题

https://www.nowcoder.com/exam/interview/detail?questionClassifyId=0&questionId=2412402&questionJobId=156&type=1


## 说一说cookie sessionStorage localStorage

1. 存储位置：首先都是存储在浏览器上的
2. 设置条件：cookie是由服务端响应头set-cookie的时候带上的，并且前端也可以通过 document.cookie来设置cookie，其他两个都是由前端去设置的。
3. 生命周期: cookie的保存时间是一个会话周期，也就是关闭页面cookie就没了，sessionStorage同样的，localStorage是持久化存储的，只要你不删除他就一直存在。
4. 作用： cookie的作用是携带用户信息，sessionID等。localstorage是为了减轻服务端请求压力。sessionStorage可以记录播放进度等，用户刷新页面的话 可以定位到具体位置。


## 说一说JS数据类型有哪些,区别是什么？

String,Number,Boolean,undefined,null,symbol,bigint,object

存储方式不同，基础数据类型存储再栈内，引用数据类型存储在堆内，栈内只记录一个堆地址。

symbol是ES6新出的数据类型，这种数据的特点就是没有重复的数据，可以作为Object的key。创建的方法是symbol();而不是new，获取的方式也不能通过for in 获取到key，需要通过object.getOwnPropertySymbols(objs)获得这个obj对象中symbolkey

bigint是为了解决超出最大安全数的精度问题


## 说一说对闭包的理解

1. 定义：函数引用外部变量就会产生闭包，即函数和函数的词法环境绑定在了一起 就是闭包

2. 产生的原因：作用域链，当前作用域可以访问上级作用域中的变量。

3. 解决了什么问题：能够让函数作用域中的变量在函数执行结束后不被销毁，同时也能在函数外部访问函数内部的局部变量。

4. 缺点： 垃圾回收不会将闭包中的变量销毁，会造成内存泄漏。累计多了会导致内存溢出。

5. 应用场景： 柯里化

```javascript
function curry(fn){
  const arg = [...arguments].slice(1);
  return function(){
    if(arguments.length === 0){
      return fn.apply(this,arg);
    }else{
      [].push.apply(arg,arguments);
      return arguments.callee;
    }
  }
}
```


## Promise


## 说一说跨域是什么？如何解决跨域问题？

1. 跨域： 当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。

2. 产生的原因： 浏览器为了保证安全，出的同源策略

3. 解决问题：
    + cors 通过设置后端允许跨域来实现
    补充一个问题 ： 携带cookie的cors
    ``` javascript
      var xhr = new XMLHttpRequest();
      /*Access-Control-Allow-Credentials 响应头会使浏览器容许在 Ajax 访问时携带 Cookie，但咱们仍然须要对 XMLHttpRequest 设置其 withCredentials 参数，才能实现携带 Cookie 的目标。*/

      /** 并且此情况不允许设置 Access-Control-Allow-Origin: *  */
      xhr.withCredentials = true;
    ```
    + node中间件 nginx反向代理,将请求发送给代理服务器，静态页面和代理服务器是同源的，然后代理服务器给服务端发送请求不存在同源限制。

    + JSONP 原理是script标签可以跨域请求资源，并将回调函数作为参数拼接在url中

    + postmessag
    e 通过发送和接收api实现跨域通信

## BFC

1. 中文名：块级格式化上下文，是Web页面一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。

2. 规则： 垂直放置，上下margin重叠，左右margin相加

3. 形成条件：float,overflow,position,display

4. 解决的问题，清除浮动，解决高度塌陷


## 说一说Vuex是什么，每个属性是干嘛的，如何使用 ？

1. 是什么：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

2. 属性：store,getter,mutation,action,module

3. 分别是做什么的,store是用来存储公共数据的，getter类似computed，只有当他的依赖值发生变化的时候，他在会跟着变化，Mutation是用于修改store数据的同步方法，Action则是异步方法，它提交的是一个mutation，module是用于拆分store数据的，它内部同样有着这几个属性。

4. 可以直接通过 mapState mapMutations等获取方法，也可以使用dispatch方法触发。

## 说一说JavaScript有几种方法判断变量的类型？

1. typeof 基础数据类型除null 返回 object 会返回基础数据类型本身，引用数据类型除Function返回function 其他返回object 

2. instanceof 用于检测当前的类型是否是在当前实例的原型链上

3. Object.prototype.toString.call() 可以判断类型的具体名称

4. constructor 根据构造器判断 
 

## 说一说样式优先级的规则是什么？

权重问题 

1. 继承最低

2. !important最高

3. 其它的根据权重累加 行内 1000 id 100 class 10 标签 1


## JS实现异步的方法

 所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。

1. setTimeout

2. callback

3. addEventListener

4. promise

5. generators / yield

6. async/await


## 说一说Vue2.0 双向绑定的原理与缺陷？

1. 原理： Vue 采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式。通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。

2. 核心API: Object.defineProperty。用来定义对象属性。

3. 缺点：一次性递归到底开销很大，如果数据很大，大量的递归可能导致调用栈移除； 不能监听对象的新增属性和删除属性； 无法正确监听数组下标对应的数据发生变化。

## 数组去重复

1. new Set

2. for + indexof lastIndexof 

3. reduce includes

4. filter + indexof 

## 说一说null 和 undefined 的区别，如何让一个属性变为null

1. undefind 是全局对象的一个属性，当一个变量没有被赋值或者一个函数没有返回值或者某个对象不存在某个属性却去访问或者函数定义了形参但没有传递实参，这时候都是undefined

2. typeof 返回 不同
3. null表示引用类型的值未被设置，通常用来释放一个对象。
4. null是关键字，undefined 不是 ；

## 说一下浮动？

1. 脱离文档流
2. 块级元素排列一行。
3. 元素不占位，导致高度塌陷

解决方法:
1. 伪元素清楚浮动
2. 开启BFC

## 说一说es6中箭头函数？

1. 箭头函数相当于匿名函数，简化了函数定义。

2.  箭头函数最大的特点就是没有this，所以this是从外部获取，就是继承外部的执行上下文中的this，由于没有this关键字所以箭头函数也不能作为构造函数， 同时通过 `call()` 或 `apply()` 方法调用一个函数时，只能传递参数（不能绑定this），第一个参数会被忽略。

3. 箭头函数也没有原型和super。不能使用yield关键字，因此箭头函数不能用作 Generator 函数。不能返回直接对象字面量。 

4. 不适用场景，作为对象的方法

5. 适用场景，内部没有this引用，没有递归，事件等。

## 说一说call apply bind的作用和区别？

1.  call、apply、bind的作用都是改变函数运行时的this指向

2. bind和call、apply在使用上有所不同，bind在改变this指向的时候，返回一个改变执行上下文的函数，不会立即执行函数，而是需要调用该函数的时候再调用即可，但是call和apply在改变this指向的同时执行了该函数。

3.  bind只接收一个参数，就是this指向的执行上文。 call、apply接收多个参数，第一个参数都是this指向的执行上文，后面的参数都是作为改变this指向的函数的参数。

4. call接受的是参数 apply接受的是数组

5. 使用场景来说,call可以用于原型继承， apply用于数组求最大最小。Math.max.apply(null,arr)

## 说一说HTML语义化？

HTML语义化就是什么内容用什么样的标签，标题就用h1-6 内容就用p，文章就用article，

作用： 

1. 有利于SEO。

2. 有利于无障碍访问。

3. 代码更具有可读性

## 说一说this指向（普通函数、箭头函数）？

1. 由来:在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 this 机制

2. 场景： 全局执行上下文，函数执行上下文，eval

3. 指向：在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window;  通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身;  new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身; 箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。

## 说一说CSS尺寸设置的单位

px rem em vh vw

## 说几个未知宽高元素水平垂直居中方法

1. position + transform

2. flexbox

3. grid;

4. table

## 说一说JS变量提升？

1. 变量提升是指JS的变量和函数声明会在代码编译期，提升到代码的最前面。

2. var function 同时函数的声明提升会比变量的提升优先

3. 使用let和const声明的变量是创建提升，形成暂时性死区，在初始化之前访问let和const创建的变量会报错。

## 说一说 HashRouter 和 HistoryRouter的区别和原理？


1. history和hash都是利用浏览器的两种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location对象hash值变化事件来实现

2. history的url没有'#'号，hash反之

3. 相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发，history需要后端配合，如果后端不配合刷新新页面会出现404，hash不需要。
<!-- 
   history 实践。 从根路径开始 三级以内为后端路由，三级以后为前端路由 这是约定

   比如 /www.pwrd.com/h5/pay/sz/index

   h5 / pay / sz 指的是再服务端的路径 后面的就是前端的路由了
 -->


4. HASH路由原理 ： 监听 onhashchange 时间获取hash值来操作

5. history路由原理 :  通过history.pushState 进行页面跳转不会触发页面刷新，并且监听onpopstate监听前进和后退



## 说一说map 和 forEach 的区别？

map有返回值，可以开辟新空间，return出来一个length和原数组一致的数组，即便数组元素是undefined或者是null。

forEach默认无返回值，返回结果为undefined，可以通过在函数体内部使用索引修改数组元素。

## 说一说事件循环Event loop，宏任务与微任务？

1. 执行js代码的时候，遇见同步任务，直接推入调用栈中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的所有同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。

2. 异步任务又分为宏任务和微任务。 宏任务：任务队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列。 微任务：等宏任务中的主要功能都完成后，渲染引擎不急着去执行下一个宏任务，而是执行当前宏任务中的微任务 宏任务包含：执行script标签内部代码、setTimeout/setInterval、ajax请、postMessageMessageChannel、setImmediate，I/O（Node.js） 微任务包含：Promise、MutonObserver、Object.observe、process.nextTick（Node.js） 加分回答 浏览器和Node 环境下，microtask 任务队列的执行时机不同 - Node端，microtask 在事件循环的各个阶段之间执行 - 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行


## 说一说Vue3.0 实现数据双向绑定的方法 ？


Proxy 

cosnt proxy = new Proxy({},{
  get(){},
  set(){},
})

## 说一下Diff算法？

patch函数中对新老节点进行比较 如果新节点不存在就销毁老节点 如果老节点不存在，直接创建新的节点 当两个节点是相同节点的时候，进入 patctVnode 的过程


## 说一说三栏布局的实现方案

1. 圣杯布局 
2. 双飞翼布局
3. flex
4. calc
5. grid

## 说一下浏览器垃圾回收机制？

1. 标记清除法

一个对象如果用了标记为1 如果没有在用了 标记为0，每隔一段时间去清除标记为0的数据。

删除之后内存的存储位置是不连续的 会产生很多内存碎片

2. 引用计数法

用一个计数器，如果声明了一个变量 那么这个引用数量为1 如果又有别的变量引用了这个变量，则+1；如果该变量被其他变量覆盖了 则 - 1；最后清楚掉引用计数为0的变量


3. 新生代老生代回收 （v8）

新老生代 V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

老生代的垃圾回收是采用引用计数法

新生代分为了两个区 ，为工作区和空闲区。当工作区满了之后，按顺序把还在使用的放到空闲区中，进行一次垃圾回收，同时将体积较大的放到老生代里 然后空闲区和工作区对换


## vue的keep-alive

1. 作用是缓存组件 ,听声性能,避免重复加载

2. 使用方法: `<keep-alive>`的使用方法：使用`<keep-alive>`标签对需要缓存的组件进行包裹, 可以给keep-alive添加属性, include exclude 判断组件是否缓存 ; 还有一种是缓存路由 我们可以设置路由mate属性  keepAlive:boolean 让其是否缓存.


## CSRF攻击是什么？

1. CSRF是跨站点请求伪造攻击,就是攻击者盗用了用户的身份，以用户的身份发送恶意请求，但是对服务器来说这个请求是合理的，这样就完成了攻击者的目标。

2. 原理是 用户打开A网站并登录,A网站会产生一个cookie信息给浏览器,在用户没有退出A网站的情况下,在同一个浏览器打开了另一个新网站B,B收到用户请求后返回了一些攻击代码,并在用户不知道的情况下,以用户身份向A发出合法请求.

3. 预防: 使用验证码 ; HTTP 中 Referer字段 ,检查是不是从正确的域名访问过来. 使用token验证,在请求头添加token 如果token不对,就拒绝该请求.


## XSS攻击是什么？

1. XSS是跨站脚本攻击,攻击者可以通过向Web页面里面插入script代码，当用户浏览这个页面时，就会运行被插入的script代码，达到攻击者的目的。

2. XSS的危害一般是泄露用户的登录信息cookie，攻击者可以通过cookie绕过登录步骤直接进入站点。XSS的分类分为反射型和存储型。反射型就是临时通过url访问网站，网站服务端将恶意代码从url中取出，拼接在HTML中返回给浏览器，用户就会执行恶意代码。存储型就是将恶意代码以留言的形式保存在服务器数据库，任何访问网站的人都会受到攻击。

3. 预防XSS攻击的方案基本是对数据进行严格的输出编码，比如HTML元素的编码，JavaScript编码，css编码，url编码等等。 一般我们会区过滤尖括号 引号 以及这两种转义后的字符.  浏览器的XSS防御,X-XSS-Protection 可以防御注入到HTML节点的内容 HTTP only cookie 禁止js读取cookie

## 