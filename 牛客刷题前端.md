# 牛客网刷题

https://www.nowcoder.com/exam/interview/detail?questionClassifyId=0&questionId=2412402&questionJobId=156&type=1


## 说一说cookie sessionStorage localStorage

1. 存储位置：首先都是存储在浏览器上的
2. 设置条件：cookie是由服务端响应头set-cookie的时候带上的，并且前端也可以通过 document.cookie来设置cookie，其他两个都是由前端去设置的。
3. 生命周期: cookie的保存时间是一个会话周期，也就是关闭页面cookie就没了，sessionStorage同样的，localStorage是持久化存储的，只要你不删除他就一直存在。
4. 作用： cookie的作用是携带用户信息，sessionID等。localstorage是为了减轻服务端请求压力。sessionStorage可以记录播放进度等，用户刷新页面的话 可以定位到具体位置。


## 说一说JS数据类型有哪些,区别是什么？

String,Number,Boolean,undefined,null,symbol,bigint,object

存储方式不同，基础数据类型存储再栈内，引用数据类型存储在堆内，栈内只记录一个堆地址。

symbol是ES6新出的数据类型，这种数据的特点就是没有重复的数据，可以作为Object的key。创建的方法是symbol();而不是new，获取的方式也不能通过for in 获取到key，需要通过object.getOwnPropertySymbols(objs)获得这个obj对象中symbolkey

bigint是为了解决超出最大安全数的精度问题


## 说一说对闭包的理解

1. 定义：函数引用外部变量就会产生闭包，即函数和函数的词法环境绑定在了一起 就是闭包

2. 产生的原因：作用域链，当前作用域可以访问上级作用域中的变量。

3. 解决了什么问题：能够让函数作用域中的变量在函数执行结束后不被销毁，同时也能在函数外部访问函数内部的局部变量。

4. 缺点： 垃圾回收不会将闭包中的变量销毁，会造成内存泄漏。累计多了会导致内存溢出。

5. 应用场景： 柯里化

```javascript
function curry(fn){
  const arg = [...arguments].slice(1);
  return function(){
    if(arguments.length === 0){
      return fn.apply(this,arg);
    }else{
      [].push.apply(arg,arguments);
      return arguments.callee;
    }
  }
}
```


## Promise


## 说一说跨域是什么？如何解决跨域问题？

1. 跨域： 当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。

2. 产生的原因： 浏览器为了保证安全，出的同源策略

3. 解决问题：
    + cors 通过设置后端允许跨域来实现
    补充一个问题 ： 携带cookie的cors
    ``` javascript
      var xhr = new XMLHttpRequest();
      /*Access-Control-Allow-Credentials 响应头会使浏览器容许在 Ajax 访问时携带 Cookie，但咱们仍然须要对 XMLHttpRequest 设置其 withCredentials 参数，才能实现携带 Cookie 的目标。*/

      /** 并且此情况不允许设置 Access-Control-Allow-Origin: *  */
      xhr.withCredentials = true;
    ```
    + node中间件 nginx反向代理,将请求发送给代理服务器，静态页面和代理服务器是同源的，然后代理服务器给服务端发送请求不存在同源限制。

    + JSONP 原理是script标签可以跨域请求资源，并将回调函数作为参数拼接在url中

    + postmessag
    e 通过发送和接收api实现跨域通信

## BFC

1. 中文名：块级格式化上下文，是Web页面一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。

2. 规则： 垂直放置，上下margin重叠，左右margin相加

3. 形成条件：float,overflow,position,display

4. 解决的问题，清除浮动，解决高度塌陷


## 说一说Vuex是什么，每个属性是干嘛的，如何使用 ？

1. 是什么：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

2. 属性：store,getter,mutation,action,module

3. 分别是做什么的,store是用来存储公共数据的，getter类似computed，只有当他的依赖值发生变化的时候，他在会跟着变化，Mutation是用于修改store数据的同步方法，Action则是异步方法，它提交的是一个mutation，module是用于拆分store数据的，它内部同样有着这几个属性。

4. 可以直接通过 mapState mapMutations等获取方法，也可以使用dispatch方法触发。

## 说一说JavaScript有几种方法判断变量的类型？

1. typeof 基础数据类型除null 返回 object 会返回基础数据类型本身，引用数据类型除Function返回function 其他返回object 

2. instanceof 用于检测当前的类型是否是在当前实例的原型链上

3. Object.prototype.toString.call() 可以判断类型的具体名称

4. constructor 根据构造器判断 
 

## 说一说样式优先级的规则是什么？

权重问题 

1. 继承最低

2. !important最高

3. 其它的根据权重累加 行内 1000 id 100 class 10 标签 1


## JS实现异步的方法

 所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。

1. setTimeout

2. callback

3. addEventListener

4. promise

5. generators / yield

6. async/await


## 说一说Vue2.0 双向绑定的原理与缺陷？

1. 原理： Vue 采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式。通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。

2. 核心API: Object.defineProperty。用来定义对象属性。

3. 缺点：一次性递归到底开销很大，如果数据很大，大量的递归可能导致调用栈移除； 不能监听对象的新增属性和删除属性； 无法正确监听数组下标对应的数据发生变化。

## 数组去重复

1. new Set

2. for + indexof lastIndexof 

3. reduce includes

4. filter + indexof 

## 说一说null 和 undefined 的区别，如何让一个属性变为null

1. undefind 是全局对象的一个属性，当一个变量没有被赋值或者一个函数没有返回值或者某个对象不存在某个属性却去访问或者函数定义了形参但没有传递实参，这时候都是undefined

2. typeof 返回 不同
3. null表示引用类型的值未被设置，通常用来释放一个对象。
4. null是关键字，undefined 不是 ；

## 说一下浮动？

1. 脱离文档流
2. 块级元素排列一行。
3. 元素不占位，导致高度塌陷

解决方法:
1. 伪元素清楚浮动
2. 开启BFC

## 说一说es6中箭头函数？

1. 箭头函数相当于匿名函数，简化了函数定义。

2.  箭头函数最大的特点就是没有this，所以this是从外部获取，就是继承外部的执行上下文中的this，由于没有this关键字所以箭头函数也不能作为构造函数， 同时通过 `call()` 或 `apply()` 方法调用一个函数时，只能传递参数（不能绑定this），第一个参数会被忽略。

3. 箭头函数也没有原型和super。不能使用yield关键字，因此箭头函数不能用作 Generator 函数。不能返回直接对象字面量。 

4. 不适用场景，作为对象的方法

5. 适用场景，内部没有this引用，没有递归，事件等。

## 说一说call apply bind的作用和区别？

1.  call、apply、bind的作用都是改变函数运行时的this指向

2. bind和call、apply在使用上有所不同，bind在改变this指向的时候，返回一个改变执行上下文的函数，不会立即执行函数，而是需要调用该函数的时候再调用即可，但是call和apply在改变this指向的同时执行了该函数。

3.  bind只接收一个参数，就是this指向的执行上文。 call、apply接收多个参数，第一个参数都是this指向的执行上文，后面的参数都是作为改变this指向的函数的参数。

4. call接受的是参数 apply接受的是数组

5. 使用场景来说,call可以用于原型继承， apply用于数组求最大最小。Math.max.apply(null,arr)

## 说一说HTML语义化？

HTML语义化就是什么内容用什么样的标签，标题就用h1-6 内容就用p，文章就用article，

作用： 

1. 有利于SEO。

2. 有利于无障碍访问。

3. 代码更具有可读性

## 说一说this指向（普通函数、箭头函数）？

1. 由来:在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 this 机制

2. 场景： 全局执行上下文，函数执行上下文，eval

3. 指向：在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window;  通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身;  new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身; 箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。

## 说一说CSS尺寸设置的单位

px rem em vh vw

## 说几个未知宽高元素水平垂直居中方法

1. position + transform

2. flexbox

3. grid;

4. table

## 说一说JS变量提升？

1. 变量提升是指JS的变量和函数声明会在代码编译期，提升到代码的最前面。

2. var function 同时函数的声明提升会比变量的提升优先

3. 使用let和const声明的变量是创建提升，形成暂时性死区，在初始化之前访问let和const创建的变量会报错。

## 说一说 HashRouter 和 HistoryRouter的区别和原理？


1. history和hash都是利用浏览器的两种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location对象hash值变化事件来实现

2. history的url没有'#'号，hash反之

3. 相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发，history需要后端配合，如果后端不配合刷新新页面会出现404，hash不需要。
<!-- 
   history 实践。 从根路径开始 三级以内为后端路由，三级以后为前端路由 这是约定

   比如 /www.pwrd.com/h5/pay/sz/index

   h5 / pay / sz 指的是再服务端的路径 后面的就是前端的路由了
 -->


4. HASH路由原理 ： 监听 onhashchange 时间获取hash值来操作

5. history路由原理 :  通过history.pushState 进行页面跳转不会触发页面刷新，并且监听onpopstate监听前进和后退



## 说一说map 和 forEach 的区别？

map有返回值，可以开辟新空间，return出来一个length和原数组一致的数组，即便数组元素是undefined或者是null。

forEach默认无返回值，返回结果为undefined，可以通过在函数体内部使用索引修改数组元素。

## 说一说事件循环Event loop，宏任务与微任务？

1. 执行js代码的时候，遇见同步任务，直接推入调用栈中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的所有同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。

2. 异步任务又分为宏任务和微任务。 宏任务：任务队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列。 微任务：等宏任务中的主要功能都完成后，渲染引擎不急着去执行下一个宏任务，而是执行当前宏任务中的微任务 宏任务包含：执行script标签内部代码、setTimeout/setInterval、ajax请、postMessageMessageChannel、setImmediate，I/O（Node.js） 微任务包含：Promise、MutonObserver、Object.observe、process.nextTick（Node.js） 加分回答 浏览器和Node 环境下，microtask 任务队列的执行时机不同 - Node端，microtask 在事件循环的各个阶段之间执行 - 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行


## 说一说Vue3.0 实现数据双向绑定的方法 ？


Proxy 

cosnt proxy = new Proxy({},{
  get(){},
  set(){},
})

## 说一下Diff算法？




## 说一说三栏布局的实现方案

1. 圣杯布局 
2. 双飞翼布局
3. flex
4. calc
5. grid

## 说一下浏览器垃圾回收机制？

1. 标记清除法

一个对象如果用了标记为1 如果没有在用了 标记为0，每隔一段时间去清除标记为0的数据。

删除之后内存的存储位置是不连续的 会产生很多内存碎片

2. 引用计数法

用一个计数器，如果声明了一个变量 那么这个引用数量为1 如果又有别的变量引用了这个变量，则+1；如果该变量被其他变量覆盖了 则 - 1；最后清楚掉引用计数为0的变量


3. 新生代老生代回收 （v8）

新老生代 V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

老生代的垃圾回收是采用引用计数法

新生代分为了两个区 ，为工作区和空闲区。当工作区满了之后，按顺序把还在使用的放到空闲区中，进行一次垃圾回收，同时将体积较大的放到老生代里 然后空闲区和工作区对换


## vue的keep-alive

1. 作用是缓存组件 ,听声性能,避免重复加载

2. 使用方法: `<keep-alive>`的使用方法：使用`<keep-alive>`标签对需要缓存的组件进行包裹, 可以给keep-alive添加属性, include exclude 判断组件是否缓存 ; 还有一种是缓存路由 我们可以设置路由mate属性  keepAlive:boolean 让其是否缓存.


## CSRF攻击是什么？

1. CSRF是跨站点请求伪造攻击,就是攻击者盗用了用户的身份，以用户的身份发送恶意请求，但是对服务器来说这个请求是合理的，这样就完成了攻击者的目标。

2. 原理是 用户打开A网站并登录,A网站会产生一个cookie信息给浏览器,在用户没有退出A网站的情况下,在同一个浏览器打开了另一个新网站B,B收到用户请求后返回了一些攻击代码,并在用户不知道的情况下,以用户身份向A发出合法请求.

3. 预防: 使用验证码 ; HTTP 中 Referer字段 ,检查是不是从正确的域名访问过来. 使用token验证,在请求头添加token 如果token不对,就拒绝该请求.


## XSS攻击是什么？

1. XSS是跨站脚本攻击,攻击者可以通过向Web页面里面插入script代码，当用户浏览这个页面时，就会运行被插入的script代码，达到攻击者的目的。

2. XSS的危害一般是泄露用户的登录信息cookie，攻击者可以通过cookie绕过登录步骤直接进入站点。XSS的分类分为反射型和存储型。反射型就是临时通过url访问网站，网站服务端将恶意代码从url中取出，拼接在HTML中返回给浏览器，用户就会执行恶意代码。存储型就是将恶意代码以留言的形式保存在服务器数据库，任何访问网站的人都会受到攻击。

3. 预防XSS攻击的方案基本是对数据进行严格的输出编码，比如HTML元素的编码，JavaScript编码，css编码，url编码等等。 一般我们会区过滤尖括号 引号 以及这两种转义后的字符.  浏览器的XSS防御,X-XSS-Protection 可以防御注入到HTML节点的内容 HTTP only cookie 禁止js读取cookie

## 说一说js继承的方法和优缺点？

1.  原型链继承：让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性，原型链继承的。

缺点：在父类型构造函数中定义的引用类型值的实例属性，会在子类型原型上变成原型属性被所有子类型实例所共享。同时在创建子类型的实例时，不能向超类型的构造函数中传递参数。

```js
function Father(name){
  this.name = name;
  this.age = 1;
}

function Person{};

Person.prototype = new Father();

```

2.  借用构造函数继承：在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上。

优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题。

缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式

3. 组合继承：将原型链和借用构造函数的组合到一块。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性。

优点: 解决了原型链继承和借用构造函数继承造成的影响。

缺点: 无论在什么情况下，都会调用两次父类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部 


4. 原型式继承:在一个函数A内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。本质上，函数A是对传入的对象执行了一次浅复制。

```js
function objectCopy(obj) {
    function Fun() {};
    Fun.prototype = obj;
    return new Fun()
}
```

5. Object.create(Father.prototype)

6. ES6 extends super


## 说一说defer和async区别？

1.  浏览器会立即加载JS文件并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行

2. 加上async属性，加载JS文档和渲染文档可以同时进行（异步），当JS加载完成，JS代码立即执行，会阻塞HTML渲染。

3. 加上defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），当HTML渲染完成，才会执行JS代码。

## 说一下浏览器如何渲染页面的？

1. 浏览器拿到HTML,先将HTML转换成dom树
2. 再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树
3. 对布局树进行分层，为每个图层生成绘制列表

4. 再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。

## computed和watch的区别？

1.  computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值

2.  watch： 更多的是观察的作用，支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作

## 说一说 Vue 中 $nextTick 作用与原理？

1.  Vue 在更新 DOM 时是异步执行的，在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。所以修改完数据，立即在方法中获取DOM，获取的仍然是未修改的DOM。

2. 原理是异步任务降级的过程 

Promise ->  MutationObserver ->  setImmediate  -> setTimeout()

## 说一说new 会发生什么

1. 构建一个新的对象
2. 绑定到构造函数原型上
3. 绑上this
4. 执行构造函数代码
5. 返回对象。


```js
function _new(fn,...args){
  _new.target = this;

  const obj = Object.create(fn.prototype)

  const res = fn.apply(obj,arg)

  if(typeof res === 'object'){
    return res
  }

  return obj
}

```

##　说一下token 能放在cookie中吗？

可以
1. 客户端使用用户名跟密码请求登录 

2. 服务端收到请求，去验证用户名与密码

3. 验证成功后，服务端签发一个 token ，并把它发送给客户端 

4. 客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里 

5. 客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里） 

6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据


## 说一下浏览器输入URL发生了什么？

1. url解析：判断是搜索内容还是请求URL 

2. 查找本地缓存：如果有缓存直接返回给页面，没有缓存则进入网络请求阶段 

3. DNS解析 

4. 通过三次握手建立TCP连接 

5. 合成请求头信息，发送http请求 

6. 处理响应信息 

7. 通过四次挥手断开TCP连接 

8. 如果响应状态码301，则重定向 

9. 浏览器进行页面渲染


## 说一说组件通信的方式？

1. props
2. $emit $on
3. inject / provide
4. eventbus
5. Vuex

##　说一说 v-if 和 v-show区别？

1. 都是控制显示隐藏
2. v-show 设置的是display:none,v-if直接没加载 并且不走组件的生命周期

##　说一说盒模型？ 

CSS盒模型定义了盒的包括的部分 margin border padding content,根据不同的计算方式分为了，标准盒模型 和 怪异盒模型 

1. 标准盒模型 设置宽高是给 content 设置其
2. 怪异盒模型 给 content padding border


##　说一说伪数组和数组的区别？

类型是object 
不能使用数组方法，有长度
可以for in
可以通过 Array.prototype.silce.call(obj)


##　说一说如何实现可过期的localstorage数据？

1. 惰性删除 惰性删除是指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。

``` js
localStorage.setItem('key',{value:1,data:Date.now()})
//  下次获取的时候 根据时间判断是否过期
```


2. 定时删除  每个一段时间来删除一次


## 说一说axios的拦截器原理及应用？

1. 拦截器原理：创建一个chn数组，数组中保存了拦截器相应方法以及dispatchRequest（dispatchRequest这个函数调用才会真正的开始下发请求），把请求拦截器的方法放到chn数组中dispatchRequest的前面，把响应拦截器的方法放到chn数组中dispatchRequest的后面，把请求拦截器和相应拦截器forEach将它们分unshift,push到chn数组中，为了保证它们的执行顺序，需要使用promise，以出队列的方式对chn数组中的方法挨个执行。

1. axios的拦截器的应用场景：   请求拦截器用于在接口请求之前做的处理，比如为每个请求带上相应的参数（token，时间戳等） 返回拦截器用于在接口返回之后做的处理，比如对返回的状态进行判断（token是否过期）。

## 说一下fetch 请求方式？

fetch是一种HTTP数据请求的方式，是XMLHttpRequest的一种替代方案。Fetch函数就是原生js，没有使用XMLHttpRequest对象。fetch()方法返回一个Promise解析Response来自Request显示状态（成功与否）的方法。 加

Fetch API规定，get方式请求数据时无法通过options传输参数，只能将数据拼接到url中；2、post方式请求数据可以通过options中传输参数，但需要在header中加入"Content-type"：application/x-www-form-urlencoded; charset=UTF-8

## 说一下有什么方法可以保持前后端实时通信？

1. 轮询

2. 长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，如果没有新消息，就一直等待。有新消息，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。

3. WebSocket是类似Socket的TCP长连接的通讯模式，一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

4. iframe流

## 说一下重绘、重排区别如何避免？

1. 重排 ：当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 

2. 重绘：当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，所以重绘跳过了创建布局树和分层的阶段。

3. 产生重排的条件：改变DOM的几何属性;改变DOM的树结构;获取DOM数值。

4. 产生重绘的条件: 只要是不触发回流，但又触发了样式改变的 DOM 操作基本都会触发重绘

5. 避免方法：1. 减少DOM操作， 2. 操作DOM时机，3. 使用性能消耗较低的属性。4.使用GPU加速，5. 控制图层关系

## 说一说 Vue 列表为什么加 key？

diff  算法相关 

## 说一说vue-router 实现懒加载的方法？

componet:import(/*webpackChunkName*/ ,'a.vue')

## 说一说前端性能优化手段？

两个方面：
+ 加载更快
  - 使传输的数据包更小，
  - 压缩图片，雪碧图，
  - 缓存

2. 渲染更快
  - 懒加载
  - 避免重绘重排


## 说一说性能优化有哪些性能指标，如何量化？


## 说一说服务端渲染？

## 说一说vue钩子函数？


## loader 是什么

loader 是一个加载器，将一个资源转换为另一个资源，比如我们将一个字符串转换成base64

``` js
const a = require('a');
const b = loader(a)
```

loader本质是一个函数，由于函数是幂等的，所以loader可以有缓存。


## plugin是什么

plugin(插件)是webpack的支柱功能,webpack整体的程序架构也是基于插件系统之上搭建的,plugin的目的在于解决loader无法实现的其他功能.


## 安装vue-loader 为什么还需要vueloadplugin

满足loader继承的一个需要 .vue文件中的script 会以.js的形式去加载。


 