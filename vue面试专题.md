# Vue 面试题话术语


## 01-Vue组件之间通信方式有哪些

根据组件之间关系讨论组件通信最为清晰有效
+ 父子组件
  - props/$emit/$parent/ref/$attrs
+ 兄弟组件
  - $parent/$root/eventbus/vuex
+ 跨层级关系
  - eventbus/vuex/provide+inject


## 02-v-if和v-for哪个优先级更高？

1. 实践中不应该把v-for和v-if放一起

2. 在vue2中，v-for的优先级是高于v-if，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是在vue3中则完全相反，v-if的优先级高于v-for，所以v-if执行时，它调用的变量还不存在，就会导致异常

3. 通常这么使用的场景是:

  - 为了过滤列表中的项目 (比如 v-for="user in users" v-if="user.isActive")。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可（比如users.filter(u=>u.isActive)）。

  - 为了避免渲染本应该被隐藏的列表 (比如 v-for="user in users" v-if="shouldShowUsers")。此时把 v-if 移动至容器元素上 (比如 ul、ol)或者外面包一层template即可。

4. 文档中明确指出永远不要把 v-if 和 v-for 同时用在同一个元素上，显然这是一个重要的注意事项。

## 03-简述 Vue 的生命周期以及每个阶段做的事

1. 每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时更新dom。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码。

2. Vue生命周期总共可以分为8个阶段：创建前后, 载入前后, 更新前后, 销毁前后，以及一些特殊场景的生命周期。vue3中新增了三个用于调试和服务端渲染场景。

3. 
  beforeCreate：通常用于插件开发中执行一些初始化任务
  created：组件初始化完毕，可以访问各种数据，获取接口数据等
  mounted：dom已创建，可用于获取访问数据和dom元素；访问子组件等。
  beforeUpdate：此时view层还未更新，可用于获取更新前各种状态
  updated：完成view层的更新，更新后，所有状态已是最新
  beforeunmount：实例被销毁前调用，可用于一些定时器或订阅的取消
  unmounted：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器


## 04-能说一说双向绑定使用和原理吗？

1. vue中双向绑定是一个指令v-model，可以绑定一个响应式数据到视图，同时视图中变化能改变该值。

2. v-model是语法糖，默认情况下相当于:value和@input。使用v-model可以减少大量繁琐的事件处理代码，提高开发效率。

3. 通常在表单项上使用v-model，还可以在自定义组件上使用，表示某个值的输入和输出控制。

4. vue3中它类似于sync修饰符，最终展开的结果是modelValue属性和update:modelValue事件；vue3中我们甚至可以用参数形式指定多个不同的绑定，例如v-model:foo和v-model:bar

### v-model和sync修饰符有什么区别

v-model  是 :value 和 @input 组合

.sync 是 @update 和 emit(update:xxx)的组合


## 05-Vue中如何扩展一个组件

1. 常见的组件扩展方法有：mixins，slots，extends等

2. 混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

3. 插槽主要用于vue组件中的内容分发，也可以用于组件扩展。

4. mixin是对Vue类的options进行混入。所有Vue的实例对象都会具备混入进来的配置行为。

extend是产生一个继承自Vue类的子类，只会影响这个子类的实例对象，不会对Vue类本身以及Vue类的实例对象产生影响。

5. 混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中组合使用，增强代码的可读性和维护性。

## 06-子组件可以直接改变父组件的数据么，说明原因

1. 所有的 prop 都使得其父子之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。但其实在vue2中你想改是可以去改的，会在控制台警告


## 07-Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？

1. 权限管理一般需求是页面权限和按钮权限的管理

2. 前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表。比如我会配置一个asyncRoutes数组，需要认证的页面在其路由的meta中添加一个roles字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过router.addRoutes(accessRoutes)方式动态添加路由即可。

按钮权限的控制通常会实现一个指令，例如v-permission，将按钮要求角色通过值传给v-permission指令，在指令的moutned钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮。


## 08 - 说一说你对vue响应式理解？


1. 所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。

2. vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖数组对象原型的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。


3. 为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的Proxy代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，第三方的扩展开发起来更加灵活了。


## 09 - 说说你对虚拟 DOM 的理解？

1. 虚拟dom顾名思义就是虚拟的dom对象，它本身就是一个 JavaScript 对象，只不过它是通过不同的属性去描述一个视图结构。

2. 将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能

3. vdom如何生成？在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler编译为渲染函数，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟dom。但它们还不是真正的dom，所以会在后续的patch过程中进一步转化为dom。



## 10 - 你了解diff算法吗？

1. Vue中的diff算法称为patching算法，它由Snabbdom修改而来，虚拟DOM要想转化为真实DOM就需要通过patch方法转换。

2. patch函数中对新老节点进行比较 如果新节点不存在就销毁老节点 如果老节点不存在，直接创建新的节点 当两个节点是相同节点的时候，进入 patctVnode 的过程，比较两个节点的内部

3. patchVnode函数比较两个虚拟节点内部 如果两个虚拟节点完全相同，返回 当前vnode 的children 不是textNode，再分成三种情况 - 有新children，没有旧children，创建新的 - 没有新children，有旧children，删除旧的

4. 如果两个都要children 则进入updateChildren : 新前 旧前比较 新后和 旧后 



## 11 - 你知道哪些vue3新特性

1. api层面Vue3新特性主要包括：Composition API、Teleport传送门、Fragments 片段、Emits选项、自定义渲染器、SFC CSS变量、Suspense


2. 另外，Vue3.0在框架层面也有很多亮眼的改进：
  + 虚拟DOM重写 
  + 编译器优化：静态提升、patchFlags、block等
  + 基于Proxy的响应式系统
  + 更好的摇树优化
  + TypeScript + 模块化


## 12 - 怎么定义动态路由？怎么获取传过来的动态参数？

1. 我们可能有一个 User 组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，例如：{ path: '/users/:id', component: User }，其中:id就是路径参数

2. 路径参数 用冒号 : 表示。当一个路由被匹配时，它的 params 的值将在每个组件中以 this.$route.params 的形式暴露出来。


## 13-如果让你从零开始写一个vue路由，说说你的思路

一个SPA应用的路由需要解决的问题是页面跳转内容改变同时不刷新，同时路由还需要以插件形式存在，所以：

1. 首先我会定义一个createRouter函数，返回路由器实例，实例内部做几件事：

  + 保存用户传入的配置项
  + 监听hash或者popstate事件
  + 回调里根据path匹配对应路由

2. 将router定义成一个Vue插件，即实现install方法，内部做两件事：

  + 实现两个全局组件：router-link和router-view，分别实现页面跳转和内容显示
  + 定义两个全局变量： route 和 router，组件内可以访问当前路由和路由器实例

## 14-能说说key的作用吗？

判断是否为同一个节点

## 15-说说nextTick的使用和原理？

1. nextTick是等待下一次 DOM 更新刷新的工具方法。

2. Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick。

3. 在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数(flushSchedulerQueue)的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值。

## 16-watch和computed的区别以及选择?

1. 计算属性可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果，computed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算。侦听器可以侦测某个响应式数据的变化并执行副作用，常见用法是传递一个函数，执行副作用，watch没有返回值，但可以执行异步操作等复杂逻辑。

2. 计算属性常用场景是简化行内模板中的复杂表达式，模板中出现太多逻辑会是模板变得臃肿不易维护。侦听器常用场景是状态变化之后做一些额外的DOM操作或者异步操作。选择采用何用方案时首先看是否需要派生出新值，基本能用计算属性实现的方式首选计算属性。


## 17-说一下 Vue 子组件和父组件创建和挂载顺序

parent created
child created
child mounted
parent mounted


## 18-怎么缓存当前的组件？缓存后怎么更新？

1. 开发中缓存组件使用keep-alive组件，keep-alive是vue内置组件，keep-alive包裹动态组件component时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。

2. 结合属性include和exclude可以明确指定缓存哪些组件或排除缓存指定组件。vue3中结合vue-router时变化较大，之前是keep-alive包裹router-view，现在需要反过来用router-view包裹keep-alive：

3. 缓存后如果要获取数据，解决方案可以有以下两种：

beforeRouteEnter：在有vue-router的项目，每次进入路由的时候，都会执行beforeRouteEnter

actived：在keep-alive缓存的组件被激活的时候，都会执行actived钩子

## 19-从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织


1. 从0创建一个项目我大致会做以下事情：项目构建、引入必要插件、代码规范、提交规范、常用库和组件

2. 目前vue3项目我会用vite或者create-vue创建项目

3. 接下来引入必要插件：路由插件vue-router、状态管理vuex/pinia、ui库我比较喜欢element-plus和antd-vue、http工具我会选axios

4. 其他比较常用的库有vueuse，nprogress，图标可以使用vite-svg-loader

5. 下面是代码规范：结合prettier和eslint即可

6. 最后是提交规范，可以使用husky，lint-staged，commitlint

## 20-实际工作中，你总结的vue最佳实践有哪些？

文档？

## 21 - 简单说一说你对vuex理解？

1. Vuex 是一个专为 Vue.js 应用开发的状态管理模式 + 库。它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

2. Vuex 解决状态管理的同时引入了不少概念：例如state、mutation、action等，是否需要引入还需要根据应用的实际情况衡量一下：如果不打算开发大型单页应用，使用 Vuex 反而是繁琐冗余的，一个简单的 store 模式就足够了。

## 22-说说从 template 到 render 处理过程

1. Vue中有个独特的编译器模块，称为“compiler”，它的主要作用是将用户编写的template编译为js中可执行的render函数。

2. 在Vue中编译器会先对template进行解析，这一步称为parse，结束之后会得到一个JS对象，我们成为抽象语法树AST，然后是对AST进行深加工的转换过程，这一步成为transform，最后将前面得到的AST生成为JS代码，也就是render函数。


## 23-Vue实例挂载的过程中发生了什么?

1. 挂载过程指的是app.mount()过程，这个过程中整体上做了两件事：初始化和建立更新机制

2. 初始化会创建组件实例、初始化组件状态，创建各种响应式数据

3. 建立更新机制这一步会立即执行一次组件更新函数，这会首次执行组件渲染函数并执行patch将前面获得vnode转换为dom；同时首次执行渲染函数会创建它内部响应式数据之间和组件更新函数之间的依赖关系，这使得以后数据变化时会执行对应的更新函数。