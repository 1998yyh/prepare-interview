// https://juejin.cn/post/6947860760840110088#heading-12

# 基础问题

## 数据类型
1.基础类型 string,number,boolean,undefined,null,symbol,bigint
2.引用类型 object(array,regexp,map,set,math)  function

## 类型判断
1. typeof 原始类型中除了 null，其它类型都可以通过 typeof 来判断。
2. instanceof 通过原型链的方式来判断是否为构建函数的实例，常用于判断具体的对象类型。
注：
对象可以通过 [Symbol.hasInstance] 偷改类型判断
```javascript
class a {
  static [Symbol.hasInstance] (_tpye){
    return tpyeof _tpye === 'number'
  }
}
1 instanceof a
```

3. Object.prototype.toString
Object.prototype.toString.call([])  // [Object Array]

4. isXXX API

## 类型转化
1. 强制转换:
转数字：
Number(false) // -> 0
Number('1') // -> 1
Number('zb') // -> NaN

转布尔值
undefined、null、false、NaN、''、0、-0 都转为 false。
其他所有值都转为 true，包括所有对象。

2. 隐式转换

对象转基本类型：
调用 Symbol.toPrimitive，转成功就结束
调用 valueOf，转成功就结束
调用 toString，转成功就结束
报错

四则运算符：
只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型
其他运算只要其中一方是数字，那么另一方就转为数字

3. 常见考点
[] == ![] // -> ? 

！可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false。
所以 [] == ![] 转化成 [] == false ，由于双等号有布尔值 会转化成Number 比较
所以 [] == false 转化成 [] == 0 , 左边是一个数组，返回它的toPrimitive的结果


## this
1. 函数是被谁调用，那么 `this` 就是谁，没有被对象调用，`this` 就是 `window`
2. new 是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
3. 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new

箭头函数：
因为箭头函数没有 this，所以一切妄图改变箭头函数 this 指向都是无效的。

4. 常见考点
```javascript
const a = {
  b: 2,
  foo: function () { console.log(this.b) }
}
function b(foo) {
  // 输出什么？
  foo()
}
b(a.foo)
```


## 闭包

1. 定义：假如一个函数能访问外部的变量，那么这个函数它就是一个闭包，而不是一定要返回一个函数。

关于闭包的一个发现：
全局下声明的变量，如果是 var 的话就直接被挂到 globe 上，如果是其他关键字声明的话就被挂到 Script 上
``` javascript
var a = 1;
let b = 2;
const c = 3;
function fn(){
  console.log(a,b,c)
}
console.dir(fn)
// 这个时候我们会发现 fn上多了一个[[scopes]]属性
// 它的值是一个数组 [0] : Script   [1]:Global
// 而在 Script上 有 a；Global上有 bc


// 但是如果

function fn2(){
  var a = 1;
  let b  = 2;
  const c = 3;
}
console.dir(fn2)
// 而在 Script上 有 ab；Global上有 c
``` 
一个理解：局部变量才是被存储在栈上，全局变量存在静态区域上，其它都存储在堆上

### 关于闭包 关于[[scopes]]
1. 闭包会把所有东西都存下来吗？
``` javascript
{
  let localVar = 1;
  let unusedVar = 2;
  function dirtyFunc2() { return localVar++ }
}
console.dir(dirtyFunc2)
// ƒ dirtyFunc()
//   [[Scopes]]: Scopes[2]
//     0: Block
//       此处没有 unusedVar
//       localVar: 1
//     1: Global {type: "global", name: "", object: Window}

```

2. 那闭包对垃圾回收没害处？
``` javascript
{
  let localVar = new Uint8Array(1000000000)
  function dirtyFunc3() { return localVar }
  function cleanFunc() { }
}
var dirtyFunc3 = null
console.dir(cleanFunc)
// ƒ cleanFunc()
//   [[Scopes]]: Scopes[2]
//     0: Block
//       localVar: Uint8Array(1000000000) [0, 0, …]
//     1: Global {type: "global", name: "", object: Window}
```

dirtyFunc3和cleanFunc共享同一个[[Scopes]]项，但这个[[Scopes]]项并不会因为dirtyFunc3被回收而动态更新！所以无辜的cleanFunc就只好一直带着这1GB的垃圾，内存泄漏妥妥的

3. 所有的javascript函数都是闭包吗？
``` javascript
console.dir(alert)
// ƒ dirtyFunc()
//   [[Scopes]]: Scopes[0]
//     No properties
```
### 关于闭包 关于函数式编程 过程式
1. 闭包是函数式编程最先引进的，基本假设就是所有量都是常量。Javascript想方设法糅合过程式与函数式两种风格，忽略了闭包的基本假设，于是造出天坑。
``` javascript
{
  let localVar = 1;
  whatever.onclick = () => localVar++;
}
```
上面的闭包非常糟糕，糟糕就在于它不是纯函数，它是有状态的。每次调用都会有副作用，得到的值都不一样，状态在哪里又找不着.

现在主流的状态管理框架Flux/Redux/Vuex的思想全都是集中状态管理。

虽然this也是JS的一个天坑，但是比起闭包来，简直好太多了。this最伟大的功勋就在于函数和环境的解耦（跟闭包正好相反）。

```javascript
let bar = function() { this.a++ }
let state = { a: 1, bar };
```
这个时候有同学就要问了，state.bar()还是有副作用的呀，得到的值还是不一样，好处在哪？好处在于
+ bar前面是什么？是一个对象state，我们现在能确定bar的副作用在哪里了；
+ bar本身没有副作用，只要我们深拷贝state，我们就能历史回放state.bar()是怎么出bug的。


只有对象保存状态，不论是字面量，还是new。函数可以读状态，写状态必须用this.xxx或者用参数把对象传进来。
为什么说2018（其实2015+就行了）年就可以少用闭包了呢？

+ 因为我们有class关键字了，以前创建用得上this的类实在是太麻烦了；
+ 因为我们有箭头函数了，用闭包保存this的做法也不必要了。
+ 严格来说箭头函数也是一种闭包，因为它是函数和词法this的组合。但是this能保证只读，函数并不能用this写状态，因此仍然满足上面说的两个好处。

## new