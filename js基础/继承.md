# 继承

https://www.jianshu.com/p/57aafceba57d
## 原型链继承

将父类的实例作为子类的原型
``` javascript 
function Parent() {
   this.isShow = true
   this.info = {

       name: "yhd",
       age: 18,

   }; 
}

Parent.prototype.getInfo = function() {
   console.log(this.info); 
   console.log(this.isShow); // true
}

function Child() {}; 
Child.prototype = new Parent(); 

let Child1 = new Child(); 
Child1.info.gender = "男"; 
Child1.getInfo(); // {name: "yhd", age: 18, gender: "男"}

let child2 = new Child(); 
child2.getInfo(); // {name: "yhd", age: 18, gender: "男"}
child2.isShow = false

console.log(child2.isShow); // false

```

### 优点

父类方法可以复用

### 缺点

1.父类引用属性会被所有子类共享，更改一个子类的引用属性，其他子类也会收到影响。
2.子类型实例不能给父类构造函数传参

## 构造函数继承

在子类构造函数中调用父类构造函数，可以在子类构造函数中使用call()和apply()方法

``` javascript
function Parent() {
  this.info = {
    name: "yhd",
    age: 19,
  }
}

function Child() {
    Parent.call(this)
}

let child1 = new Child();
child1.info.gender = "男";
console.log(child1.info); // {name: "yhd", age: 19, gender: "男"};

let child2 = new Child();
console.log(child2.info); // {name: "yhd", age: 19}
```

### 传递参数

Parent构造函数接收一个name参数，并将他赋值给一个属性，在Child构造函数中调用Parent构造函数时传入这个参数， 实际上会在Child实例上定义name属性。为确保Parent构造函数不会覆盖Child定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性

``` javascript 
function Parent(name) {

    this.info = { name: name };

}
function Child(name) {

    //继承自Parent，并传参
    Parent.call(this, name);
    
     //实例属性
    this.age = 18

}

let child1 = new Child("yhd"); 
console.log(child1.info.name); // "yhd"
console.log(child1.age); // 18

let child2 = new Child("wxb"); 
console.log(child2.info.name); // "wxb"
console.log(child2.age); // 18

```

### 优点

可以在子类构造函数中向父类传参数
父类的引用属性不会被共享

### 缺点

子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

## 组合继承

组合继承综合了原型链继承和盗用构造函数继承(构造函数继承)，将两者的优点结合了起来，

基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性

``` javascript 
function Parent(name) {
   this.name = name
   this.colors = ["red", "blue", "yellow"]
}
Parent.prototype.sayName = function () {
   console.log(this.name);
}

function Child(name, age) {
   // 继承父类属性
   Parent.call(this, name)
   this.age = age;
}
// 继承父类方法
Child.prototype = new Parent();

Child.prototype.sayAge = function () {
   console.log(this.age);
}

let child1 = new Child("yhd", 19);
child1.colors.push("pink");
console.log(child1.colors); // ["red", "blue", "yellow", "pink"]
child1.sayAge(); // 19
child1.sayName(); // "yhd"

let child2 = new Child("wxb", 30);
console.log(child2.colors);  // ["red", "blue", "yellow"]
child2.sayAge(); // 30
child2.sayName(); // "wxb"
```

### 优点

父类的方法可以复用
可以在Child构造函数中向Parent构造函数中传参
父类构造函数中的引用属性不会被共享

## 原型式继承

对参数对象的一种浅复制

利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。
object()对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。之所以要这样创造一个空对象，就是为了看后续继续添加属性的过程不会污染原来的对象

```javascript
function objectCopy(obj) {
    function Fun() {};
    Fun.prototype = obj;
    return new Fun()
}

let person = {
    name: "yhd",
    age: 18,
    friends: ["jack", "tom", "rose"],
    sayName: function() {
        console.log(this.name);
    }
}

let person1 = objectCopy(person);
person1.name = "wxb";
person1.friends.push("lily");
person1.sayName(); // wxb

let person2 = objectCopy(person);
person2.name = "gsr";
person2.friends.push("kobe");
person2.sayName(); // "gsr"

console.log(person.friends); // ["jack", "tom", "rose", "lily", "kobe"]
```
### 缺点
原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
无法传递参数

### extend
extend函数做的就是创造一个空对象作为Child的prototype，该空对象的__proto__又指向Parent

```javascript
    function extend(Child, Parent) {
        var F = function() {};
        F.prototype = Parent.prototype;
        Child.prototype = new F();
        Child.prototype.constructor = Child;
    }
```

### 